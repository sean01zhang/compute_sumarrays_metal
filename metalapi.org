#+TITLE: Metal
#+SUBTITLE: Using Metal API for Compute
#+OPTIONS: html-postamble:nil

* Introduction
I wanted to use the GPU for some intesive tasks in C++. However, I have a macbook so
I guess we can try it using metal. Here is a note to self on how to do it.
To make it clear, this is my first time working with CMake.

* Project Structure
We will need the metal-cpp library from Apple first. Then, place that into a folder called
~lib~, under the root of the project. \\
Then, we will use cmake to generate build files for the project.
This is all new to me, so I decided to quickly ask Bing chat what it thought was
a good idea:
#+begin_src
Here are some steps to set up a basic CMake that includes the Metal APIs:
1. First, you need to install CMake on your system. You can download it from the official website.
2. Next, you need to create a new CMake project and add the Metal APIs to it. You can do this by adding the following lines to your CMakeLists.txt file:

```
cmake_minimum_required(VERSION 3.0)
project(MyMetalProject)

set(CMAKE_CXX_STANDARD 14)

find_library(METAL_LIBRARY Metal)
find_library(CORE_FOUNDATION_LIBRARY CoreFoundation)

add_executable(MyMetalProject main.cpp)

target_link_libraries(MyMetalProject ${METAL_LIBRARY} ${CORE_FOUNDATION_LIBRARY})
```

3. Now you can create a new file called main.cpp and add some code that uses the Metal APIs.

4. Finally, you can build your project using CMake and run it.

I hope this helps! Let me know if you have any other questions.
#+end_src

** Source Files
We will put the code under a folder called ~src/~. We name our starting point ~main.cpp~, but you can
name it something else if you please. Just make sure you update the Cmake file.

** Building Project
First, we have to configure cmake. This is a bit different from the CMakeLists suggested from Bing above.
I encountered problems with ~find_library~ finding the ~CoreFoundation~ library. I specified ~NO_DEFAULT_PATH~, which resolved it finding a CoreFoundation library on my
system rather than in the project, but then it couldn't find the one in my project even when I gave it hints.
Instead, I decided to ditch that and manually input the frameworks as shown:

*CMakeLists.txt*
#+begin_src c :tangle CMakeLists.txt
cmake_minimum_required (VERSION 3.20)
project (compute_sumarrays)

set(CMAKE_CXX_STANDARD 17)
# set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror")

include_directories(${CMAKE_SOURCE_DIR}/lib/metal-cpp)

add_executable(compute_sumarrays
  ./src/main.cc
)

target_link_libraries(compute_sumarrays
  stdc++ 
  "-framework Metal"
  "-framework Foundation"
  "-framework QuartzCore"
  objc
)
#+end_src

Place this file in the root of your directory. The reason why I commented out the flags
is because one of the header files in the metal-cpp library is triggering a warning.

Now that your ~CMakeLists.txt~ file is set up, here is what to do next:
#+begin_src bash
  # you should be in the root of your project
  pwd

  mkdir build
  cd build
  # start configuration, 2nd argument is
  # the path to the CMakeLists.txt directory.
  cmake ../
#+end_src

This will generate a Makefile in your ~build~ directory.
You do not need to do anything to that file. When ready to
build, just type ~make~ in that directory, and it will
create an executable which will have the same name as your project.

* Initialization
Once all the structure is there, we move on to the main file of our project.
We need to set up a compute pipeline for metal. I referenced [[https://developer.apple.com/documentation/metal/performing_calculations_on_a_gpu?language=objc][this]] to help me get started.
There are a few changes that I made, the first one being that I need to import the metal library by providing the path
to a compiled ~.metallib~ file (more on that later). Everything else is mostly the same.

#+NAME: StartingPoint
#+begin_src C++ :tangle ./src/main.cc
  #define NS_PRIVATE_IMPLEMENTATION
  #define CA_PRIVATE_IMPLEMENTATION
  #define MTL_PRIVATE_IMPLEMENTATION
  #include <Foundation/Foundation.hpp>
  #include <Metal/Metal.hpp>
  #include <QuartzCore/QuartzCore.hpp>

  #include <iostream>

  int main() {
    // create device
    MTL::Device * device = MTL::CreateSystemDefaultDevice();
    NS::Error * error;

    // create command queue
    MTL::CommandQueue * command_queue = device->newCommandQueue();
    // create command buffer
    MTL::CommandBuffer * command_buffer = command_queue->commandBuffer();
    // create command encoder
    MTL::ComputeCommandEncoder * command_encoder = command_buffer->computeCommandEncoder();

    // ** Create pipeline state object
    NS::String* libPath = NS::String::string("./shader.metallib", NS::UTF8StringEncoding);
    auto default_library = device->newLibrary(libPath, &error);
    if (!default_library) {
      std::cerr << "Failed to load default library.";
      std::exit(-1);
    }

    auto add_arrays_function_name = NS::String::string("add_arrays", NS::ASCIIStringEncoding);
    auto add_function = default_library->newFunction(add_arrays_function_name);
    if (!add_function) {
      std::cerr << "failed to find the adder function";
    }

    auto pso = device->newComputePipelineState(add_function, &error);
    // free defualt library and add function
    add_arrays_function_name->release();
    default_library->release();
    add_function->release();

    // pass pipeline state object created
    // into the command encoder
    command_encoder->setComputePipelineState(pso);


    // ** Create data buffers
    // TODO: Make data and determine its size
    int array1[] = {1, 2, 3, 4, 5, 6};
    int array2[] = {1, 1, 1, 1, 1, 1};
    size_t arraySize = 6;
    size_t bufferSize = arraySize * sizeof(int);

    MTL::Buffer * a = device->newBuffer(bufferSize, MTL::ResourceStorageModeShared);
    MTL::Buffer * b = device->newBuffer(bufferSize, MTL::ResourceStorageModeShared);
    MTL::Buffer * out = device->newBuffer(bufferSize, MTL::ResourceStorageModeShared);

    // copy data into buffers
    memcpy(a->contents(), array1, bufferSize);
    memcpy(b->contents(), array2, bufferSize);

    // pass argument data into the command encoder
    command_encoder->setBuffer(a, 0, 0);
    command_encoder->setBuffer(b, 0, 1);
    command_encoder->setBuffer(out,0, 2);

    // set thread count and organization, then run the damn thing
    MTL::Size gridSize = MTL::Size(arraySize, 1, 1);

    NS::UInteger threadsPerThreadgroup = pso->maxTotalThreadsPerThreadgroup();
    MTL::Size threadgroupSize(threadsPerThreadgroup, 1, 1);

    command_encoder->dispatchThreads(gridSize, threadgroupSize);
    command_encoder->endEncoding();

    command_buffer->commit();

    // wait for the GPU work is done
    command_buffer->waitUntilCompleted();

    // read results from buffer
    int * result = (int *)out->contents();

    std::cout << "results:" << std::endl;
    for (size_t i = 0; i < arraySize; ++i) {
      std::cout << result[i] << std::endl;
    }

    a->release();
    b->release();
    out->release();
    pso->release();
    command_queue->release();
    device->release();

    return 0;
  }
#+end_src


* Our shader code
Note: Apple has documentation on [[https://developer.apple.com/documentation/metal/performing_calculations_on_a_gpu?language=objc][metal]]. You can even read the shading language reference [[https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf][here]].
Metal has a lot of similarities to C++14. Here is the add arrays function that we will create:
#+begin_src c :tangle ./src/shader.metal
  kernel void add_arrays(device const int * a, device const int * b,
                         device int * result, uint index [[thread_position_in_grid]]) {
    result[index] = a[index] + b[index];
  }
#+end_src

* Running the project
I want to be able to decouple myself from XCode as far as possible. Hence why I used CMake.
Here is how my project is structured at the moment:
#+begin_src
  .
  ├── CMakeLists.txt
  ├── build
  │   ├── CMakeCache.txt
  │   ├── CMakeFiles
  │   │   └── ...
  │   ├── Makefile
  │   ├── buildshader.sh
  │   ├── cmake_install.cmake
  │   ├── compute_sumarrays
  │   └── shader.metallib
  ├── lib
  │   └── metal-cpp
  │       └── ...
  ├── metalapi.html
  ├── metalapi.org
  └── src
      ├── main.cc
      ├── shader.metal
      └── shader.metallib

#+end_src

** Compiling Your Metal Library
Since we are not using XCode, we cannot use ~device->getDefaultLibrary()~ to magically compile and import our metal shaders.
Hence, as hinted in the source code, we will have to compile our shaders into a metal library to import.

You will need XCode Command Line Tools. See documentation [[https://developer.apple.com/documentation/metal/shader_libraries/compiling_shader_code_into_a_library_with_metal_s_command-line_tools?language=objc][here]] for full instructions on how to compile shader code.

Here is a TLDR: \\
1. Go to the directory with your ~shader.metal~ file.
2. Run the following:
   #+begin_src bash
     xcrun -sdk macosx metal -c shader.metal -o shader.air
     xcrun -sdk macosx metallib shader.air -o shader.metallib
   #+end_src
3. copy the shader.metallib file to your ~build~ directory.

** Running your code
Next, you will need to run ~make~ in your build directory. It will produce an executable.
Then, run your program.
#+begin_src sh
  ./compute_sumarrays
#+end_src

*Output*
#+RESULTS:
| results: |
|        2 |
|        3 |
|        4 |
|        5 |
|        6 |
|        7 |

Note: Every single time you change your source code, you will need to run ~make~ again.

* Next Steps
It took me a very long time to get my project to compile, but its all worth it because I can
do all of this without using an XCode project.

Now that I can add two arrays using metal, let's try rewriting my ray tracer using metal.

* Addendum
After encountering several problems, I have realised that turning my ray tracer into metal
shader code is not as easy as initially thought. Here are some ranodm things I have learned
so that my week of pain does not have to occur again:

** Simd
simd allows me to define vector types (like float3) that can be understood by the GPU as
well. Thus, my C++ code and metal code can share custom classes by defining the
class in a header file and leaving the implementation in metal (I think? As long as
the constructor is defined in the header I dont see why not)

** Compiling multiple metal files
To create a single file metal lib file at the end, you will need to compile all your
metal files into .air files (you do not need to worry about the header files). Then,
run
#+begin_src sh
xcrun -sdk macosx metal-ar rcs <archive name> *.air
#+end_src

This should put all of your files into a single archive. You can then run ~metallib~ on
that archive file.

** Randomness
Turns out, there is no random generator included in metal. So, if I need to generate a random
number in my shader, I will have to include a custom library.
Credits to this forum: [[https://developer.apple.com/forums/thread/26454][Apple Form]] \\

If I need to seed my RNG, I can pass in a noise texture from my main code to the shaders. I haven't
tested if this is necessary though

** Writing to a 2D Output Buffer
All the buffers I've worked with are 1D. How do I take my 2D array of float3's
and write to them in metal?

*** Textures
So you need a texture. To initialize a texture:
**** Building a Texture Descriptor
In a descriptor, you will need to set the
width, height, pixel format, texture type, storage mode, and usage.
Example:
#+begin_src C++
  MTL::TextureDescriptor * desc = MTL::TextureDescriptor::alloc()->init();
  desc->setWidth(800);
  desc->setHeight(600);
  desc->setPixelFormat(MTL::PixelFormatRGBA8Unorm);
  desc->setTextureType(MTL::TextureType2D);
  desc->setStorageMode(MTL::StorageModeManaged);
  desc->setUsage(MTL::ResourceUsageRead | MTL::ResourceUsageWrite);
#+end_src

Here is the documentation for MTL::TextureDescriptor: [[https://developer.apple.com/documentation/metal/mtltexturedescriptor?language=objc][apol dot com]]

TLDR:
- width and height are self-explanatory
- you can also set depth, for layers I guess?
- pixel format determines how many channels (R, RG, RGBA) and how many bits per channel (8, 16), as well
  as the data type of each component. UNorm means that floats in the range [0, 1] are stored as
  an unsigned integer from 0 to UINT_MAX. \\
  In the case of RGBA8Unorm, each component is 8 bits, ranging from 0 to $255$.
- texture type describes the way the data is arranged, (1D, 2D, etc...)
- Storage Mode determines where and who has the resources. MTLStorageModeShared stores
  the resource in system memory and can be accessed by both CPU and GPU.
  Managed requires you to manually synchronize the changes.
- Usage enables reading or writing to the resource in a shader.

**** Creating a texture
You call ~device->newTexture(desc)~ and save it as a texture pointer:
#+begin_src C++
  MTL::Texture * myTexture = device->newTexture(desc);
  desc->release();
#+end_src

You can free the description after creating the new texture.

**** Passing the texture as an argument
To pass a buffer into the function, you would do the following:
#+begin_src C++
  command_encoder->setBuffer(myBuffer, offset, index);
#+end_src

where offset tells you where the data begins from the start of the buffer (in bytes), and
index is the index in the buffer argument table. This is not always
correlated to the index of the argument passed into the function.

You do a similar thing with textures:
#+begin_src C++
  command_encoder->setTexture(myTexture, index);
#+end_src

The difference is that you are passing in a texture and the index determines the index
in the *texture* argument table.

**** Finishing up Pipeline setup
You need to decide how you want to dispatch the threads.
#+begin_src C++
  MTL::Size gridSize = MTL::Size(textureWidth, textureHeight, 1);
  NS::UInteger maxThreads = pso->maxTotalThreadsPerThreadgroup();
  MTL::Size threadgroupSize = MTL::Size(maxThreads, 1, 1);
#+end_src

**** Your Shader
Let's do an example of a shader that takes a matrix and an array and performs some
calculation on it.
#+begin_src C++
  #include <metal_stdlib>
  using namespace metal;

  kernel void shader(texture2d<float, access:write> tex [[texture(0)]],
                     uint2 index [[thread_position_in_grid]]) {
    mt19937 mt;
    mt.srand(index);
    tex.write(float3(mt.rand(), mt.rand(), mt.rand()), index, 0);
  }
#+end_src

**** Reading the result
Next, the result needs to be read. This can be done using the ~getBytes()~ function.
We will need to pass in four parameters:
- A pointer to write to: Make sure you have allocated space for the data to be written to!
- Number of bytes per row: In this case, it's 4 8-bit components (RGBA) per pixel multiplied by the
  width of the texture
- Destination region is just the region of pixels in the texture
- Mipmap level is zero in our case.

Example:
#+begin_src C++
  int bytesPerRow = out->width() * sizeof(simd::uchar4);
  int bytesPerImage = out->height() * bytesPerRow;

  MTL::Region destinationRegion = MTL::Region::Make2D(0, 0, out->width(), out->height());
  simd::uchar4 * pixelBytes = (simd::uchar4 *) malloc(bytesPerImage);
  out->getBytes(pixelBytes, bytesPerRow, destinationRegion, 0);

  int length = out->width() * out->height();
  std::cout << "results:" << std::endl;
  for (size_t i = 0; i < length; ++i) {
    for (size_t j = 0; j < 4; ++j) {
      std::cout << (float)pixelBytes[i][j]/ UCHAR_MAX  << " ";
    }
    std::cout << std::endl;
  }

  free(pixelBytes);
#+end_src

